========================================================================
    ПРИЛОЖЕНИЕ : Обзор проекта Sketcher
========================================================================

Это приложение Sketcher создано автоматически с помощью мастера 
приложений.  

Здесь приведены краткие сведения о содержимом каждого из файлов, использованных 
при создании приложения Sketcher.

Sketcher.vcxproj
    Это основной файл проекта VC++, автоматически создаваемый с помощью мастера 
    приложений. 
    Он содержит данные о версии языка Visual C++, использованной для создания 
    файла, а также сведения о платформах, настройках и свойствах проекта, 
    выбранных с помощью мастера приложений.

Sketcher.vcxproj.filters
    Это файл фильтров для проектов VC++, созданный с помощью мастера 
    приложений. 
    Он содержит сведения о сопоставлениях между файлами в вашем проекте и 
    фильтрами. Эти сопоставления используются в среде IDE для группировки 
    файлов с одинаковыми расширениями в одном узле (например файлы ".cpp" 
    сопоставляются с фильтром "Исходные файлы").

Sketcher.cpp
    Это основной исходный файл приложения.
    Код для отображения формы.

Form1.h
    Реализация класса формы и функции InitializeComponent().

AssemblyInfo.cpp
    Пользовательские атрибуты для изменения метаданных сборки.

/////////////////////////////////////////////////////////////////////////////
Другие стандартные файлы:

StdAfx.h, StdAfx.cpp
    Эти файлы используются для построения файла предкомпилированного заголовка 
    (PCH) с именем Sketcher.pch и файла предкомпилированных типов 
    с именем StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////

Область между #pragma region и #pragma endregion нельзя изменять.

Свойства TabIndex элементов управления устанавливает приоритет фокуса элементов, начинается оно с 0.
У элемента управления со свойством TabIndex = 0 обладает фокусом.

Свойства объекта MouseEventArgs:
	Button -- Свойство тип перечисления System::Windows::Forms::MouseButtons, указывающее нажатую кнопку мыши.
			В перечислении MouseButton для этого свойства доступны следующее возможные значения:
				MouseButtons::Left -- левая кнопка мыши;
				MouseButtonst::Right -- правая кнопка мыши;
				MouseButtons::None -- не была нажата никакая из кнопок мыши;
				MouseMiddle::Middle -- средняя кнопка мыши;
				MouseButtons::XButton1 -- первая кнопка XButton;
				MouseButtons::Xbuuton2 -- вторая кнопка XButton;
	Location -- Свойства перечисления System::Drawing::Point, указывающее местоположения курсора.
			Своцства X и Y объекта Point предоставляют int значения координат x и y;
	X -- Координата х курсора мыши в виде значения типа int;
	Y -- Координата y курсора мыши в виде знвчения типа int;
	Clicks -- Количество раз, которое кнопка мыши была нажата и отпущена, в виде значения типа int;
	Delta -- Количество щелчков, на которое было покручено колесо мыши, в виде знакового значения типа int;


Класс System::Drawing::Color инкапсулирует значения типа ARGB(32 - битовое значение разделённое по 8 бит)
	A -- прозрачность от 0 до 255 (0 прозрачный, 255 - непрозрачный);
	RGB -- Red, Green & Blue.


Для рисования линии соответсвующего цвета функции Draw() будет использован объект System::Drawing::Graphics,
представляемый её в качестве аргумента. Функции, доступные в классе Graphics:
	DrawLine(Pen pen, Point p1, Point p2) -- рисует линию из точки p1 до p2. Цвет и толщина линии задаёт объект Point.
	DrawLine(Pen pen, int x1, int y1, int x2, int y2)
	DrawLines(Pen pen, Point[] pts) -- рисеут ряд линий, соединяя точки в массиве pts.
	DrawRectangle(Pen pen, rectangle rect)
	DrawRectangle(Pen pen, int x, int y, int width, int height)
	DrawEllipse(Pen pen, Rectangle rect) -- рисует эллипс в указанную ограничивающим прямоугольником.
	DrawEllipse(Pen pen, int x, int y, int width, int height)


Pen^ pen = gcnew Pen(Color::Black);		
Pen^ pen = gcnew Pen(Color::Black, 2.0f);		второй аргумент это толщина линии типа float.
pen->Width = 3.0f;
pen->SetColor(Color::Red);
Свойтва объекта Pen:
	Color -- Возвращает или устанавливает цвет пера в виде значения типа.		pen->Color = Color::Red;
	Width -- Возвращает ил устанавливает толщину линии пера в виде значения типа float;
	DashPattern -- Возвращает ил устанавливает массив значений типа float, определяющих образец пунктира
			для линии. Значения в этом массиве указывает на длину чередующихся пунктиров и пробелов в линии.
			Например:		array<float>^ patter = {5.0f, 2.0f, 4.0f, 3.0f};
							pen->DashPattern = pattern;
	DashOffset -- Задаёт расстояния от начало линии до начало пунктирного образца в виде значения типа float.
	StartCap -- Задаёт стиль наконечника(cap) для начала линии. За стили наконечников отвечаетперечисления
			System::Drawing::Drawing2D::LineCap, в котором доступны след. значения:
			Flat, Square, Round, Triangle, NoAnchor, SquareAnchor, Round Anchor, Diamond Anchor, ArrowAnchor, Custom и AnchorMask
			Например, чтобы нарисовать линию, закруглённую в начале, можно установить данное свойтво след. образом:
				pen->StartCap = System::Drawing::Drawing2D::LineCap::Round;
	EndCap -- Задаёт стиль наконечника для конца линии. Возможные значения выглядат точно так же, как и в случае StartCap.


Функции преобразования системы координат класса Graphics:
	TranslateTransform(float dx, float dy) -- перемещает начало отсч	та системы координат на dx по x и на dy по оси y;
	RotateTransform(float angel) -- поварачивает систему координат относительно начальной точки на angel градусов.
			Положительное направление -- по часавой стрнелке.
	ScaleTransform(float scaleX, float scaleY) -- масштабирует ось х за счёт умножения на scaleX, а ось y на scaleY.
	ResetTransform() -- сбрасывает все вып. преобразования.


Для того чтобы перерисовка элемента выполнялась правильно в качестве аргумета функции Invalidate()
должен передаватся не ограничивающий прямоугольник элемента, а описывающий, поскольку формы простираются
дальше правых и нижних краёв ограничивающего прямоугольника на тольщину пера. Поэтому чтобы всё работала
правильно, необходимо откорректировать существующие ограничивающие прямоугольники, чтобы учесть ширину пера.


Стиль линии определяется в свойстве DashPattern объекта Pen:
	array<float>^ pattern = {5.0f, 3.0f};		для определения длины сегментов и пробелов
	pen->DashPattern = pattern;


Шрифт, предназначенный длярисования строки, задаётся с помощью объекта System::Drawing::Font, который определяет
гарнитуру, стиль и размер прописываемых символов. Объект типа System::Drawing::FamilyFont определяет группу шрифтов
с определённой гарнитурой, например Arial или Courier New. Перечисления System::Drawing::FontStyle определяет
возможные стили шрифтов, которые могут иметь вид одного из след. значений: Regualar, Bold, Italic, Underline или Strikeout.

Перегруженные версии функции DrawString() для рисования текста:
	DrawString(String^ str, Font^ font, Brush^ brush, PointF point) - Рисует строку в позиции point с использованием шрифта,
			указанного в аргументе font, и цвета, заданного аргументом brush. Под Windows::Drawing::PointF 
			подразумевается точка, представленная с помощью координат типа float. В льюбой из версии этой функции
			в качестве аргумета для параметра PointF может использоватся объект Point.
	DrawString(String^ str, Font^ font, Brush^ brush, float X, float Y)
	DrawString(String^ str, Font^ font, Brush^ brush, RectangleF rect) - рисует строку в пределах прямоугольника.
			Под Windows::Drawing::RectangleF подразумевается прямоугольник, позиция, штртна и высота которого указаны
			с помощью значений типа float. В льюбой из версий этой функции в качестве аргумента для параметра
			RectangleF может использоватся объект Rectangle.
	DrawString(String^ str, Font^ font, Brush^ brush, PointF point, StringFormat^ format) - Объект StringFormat
			определяет выравнивание и другие свойства форматирования строки.
	DrawString(String^ str, Font^ font, Brush^ brush, float X, float Y, StringFormat^ format)
	DrawString(String^ str, Font^ font, Brush^ brush, RectangleF rect, StringFormat^ format)

Создание объекта Font:
	FontFamily^ family = gcnew FontFamily(L"Arial");
	System::Drawing::Font^ font = gcnew System::Drawing::Font(family, 10, FontStyle::Bold, GraphicsUnit::Pixel);
		аргументы:			тип шрифта, размер, тип, определяет единицы измерения размера шрифта.

Значения перечисления GraphicUnit - единица измерения размера шрифта:
	World - мировая система координат
	Display - единица измерения устройства отображения: для мониров пиксел, для принтеров 1/100 дьюм.
	Pixel - пиксел
	Point - пункт(1/72 дьюм)
	Inch - дьюм
	Document - 1/300 дьюм
	Millimeter - миллиметр

Объек System::Drawing::Brush определяет цвет, используемый при рисования строк заданным шрифтом, а также может
применятся для указания цвета и текстуры, которые должны использоватся для заливки фигуры.
Создат объект Brush напрямую нельзя, потому что он является абстрактным классом. Поэтому кисти создаются с
применением таких классов, как SolidBrush, TextureBrush и LinearGradientBrush, который происходит от класса Brush.
	SolidBrush - однацветная сплошная кисть.
	TextureBrush - кисть, использующий рисунок для заливки внутренней области фигуры.
	LinearGradientBrush - кисть, применяющую градиентную смесь, которая обычно состоит из двух или нескольких цветов.

Создание объекта SolidBrush:
	SolidBrush^ brush = gcnew SolidBrush(Color::Red);



ДВОИЧНАЯ СЕРИАЛИЗАЦИЯ
Сериализация - это процесс записи объектов в поток, а Десериализация обратный процесс.
Чтобы объекты клссов могли подвергатся сериализации, его надо сделать сериализуемым. Также нужно чтобы все поля
этого объекта тоже были сериализуемыми. Но очень часто некоторые поля не явл. сериализуемыми по умолчанию или
их сериализация не имеет смысла(поскольку посе десериализации они не будут действительными). Но сущ. поля, которые
нельзя сериализиривоть из соображений безопастности. Надо подключить пространство имён System::Runtime::Serialization.

	[Serializable]
	public ref class MyClass
	{
	public:
		[NonSerialized]
		int value;

		[OnSerializing]
		void FixNonSerializedData(StreamingContext context)
		{
			//Вызывается вначале процесса сериализации
		}

		[OnSerialized]
		void PostSearization(StreamingContext context)
		{
			//Вызывется после сериализации.
		}

		[OnDeserializing]
		void PreSerialization(StreamingContext context)
		{
			//Вызывается перед началом процесса десериализации
		}

		[OnDeserialized]
		void ReconstructObject(StreamingContext context)
		{
			//Вызывается после десериализации
		}

		Все это функции должны иметь тип воззвращаемого значения void и параметр типа StramingContext(-это структура
		содержащая инфо об источнике и названии).
	}

Хотя добавления к переменной-члену атрибута NonSearialized исключает вероятность возникновения во время сериализации
проблем с теми типами данных, которые нельзя сериализовать, он не решает проблемы сриализации объектов, если только
несериализуемые данные не могут без проблем пропускатся при достижении этапа воссоздания объекта во время его десериализации.
В отношении полей с атрибутами NonSearilised обычно будут предприниматся какие-то специальные действия. 


Кадый поток представляется с помощью класса Sysytem::IO::Stream, который относится к типу абстрактных ссылочных класссов.
Потоком может быть любой источник или пункт назначения для данных, имеющих вид последовательности байтов, например, файл,
сокет TCP/IP или канал, позволяющий данным передаватся между двумя процессами.
Все статические функции для создания объектов, инкапсулирующих файл, содержатся в классе System::IO::File.
Для создания нового файла или открытия существующего для чтения и/или записи применяется функция File::Open().
Эта функция возвращает ссылку типа FileStream, указывающий на объект, который инкапсулирует файл.
Тип FileStream является производной от типа Stream.

	FileStream^ Open( String^ path, FileMode mode );

Значения, доступные в перечислении FileMode:
	CreateNew - создаёт ровый файл, путь к которому задан параметром path. Если он уже сущ. то создаётся исклбчение
			System::IO::IOException. Применяется при записи.
	Truncate - ... Его содержимое удаляется в результате усечения размера файла до 0 байта. Применяется при записи
			существующего файла.
	Create - Указывает, что в случае отсутствия указанного файла должен быть создан новый файл, а в случае его
			существования файл должен быть перезаписан. Применяется при записи файла.
	Open - ... Если такого файла нет, передаётся исключение System::IO::FileNotFindException.
			Применяется при чтении файла.
	OpenOrCreate - ... Если такой файл сущ. и создаёт новый иначе. Может применятся как при чтении тиа и при записи
			файла, в зависимости от того, какое значение указано в аргументе access.
	Append - ... , если такой сущ., а затем переместить его в позицию записи в самый конец, или же создать новый
			файл, если такой не сущ. Применятся при добавлении записи в уже сущ. файл.

Создания для записи поток:
	Stream^ stream = File::Open(L"sketch.dat", FileMode::Create);

Статическая функция OpenWrite() в классе File будет открывать сущ. файл для записи, и возвратит ссылку FileStream^
на используемыйпоток. Для сериализации объекта в файл, который был инкапсулирован в созданном объекте FileStream^,
применяется объект типа System::Runtime::Serialization::Formatters::Binary::BinaryFormatter, который создаётся так:
	
	#using System::Runtime::Serialization::Formatters::Binary;
	
	BinaryFormatter^ formatter = gcnew BinaryFormatter();
	formatter->Serialize(stream, Obj);											//запись объекта Obj в поток stream
	MyClass^ Obj = safe_cast<MyClass^>(formatter->Deserialize(stream));			//чтения объекта Obj из поток stream

!!! Все контейнеры не сериализуемы. Объекты Pen и Brush тоже несериализуемы.